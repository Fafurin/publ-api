# API СИСТЕМЫ УПРАВЛЕНИЯ ИЗДАТЕЛЬСТВОМ ПЕНЗЕНСКОГО ГОСУДАРСТВЕННОГО УНИВЕРСИТЕТА

**Технологии:** Symfony PHP, PostgreSQL

**Приложение предназначено для управления задачами сотрудников редакторского отдела и отдела оперативной полиграфии. В дальнейшем возможно внедрение приложения в работу других отделов издательства.**

Все сотрудники разделяются на _пользователей_ и _администраторов_.

### Возможности пользователя:
* регистрация и аутентификация в приложении;
* просмотр текущих задач;
* завершение задач;
* просмотр подробной информации о выполняемых заказах;
* внесение изменений в поля заказа;
* добавление файлов к заказу;
* изменение личных данных в личном кабинете.

### Возможности администратора:
* аутентификация в приложении;
* просмотр, создание, изменение и удаление типов книжных изданий;
* просмотр, создание, изменение и удаление форматов книжных изданий;
* просмотр, создание, изменение и удаление статусов заказов и задач;
* просмотр, создание, изменение и удаление должностей сотрудников;
* просмотр, создание, изменение и удаление заказов на книжные издания;
* просмотр информации о сотрудниках;
* просмотр и редактирование информации о задачах;
* постановка задач сотрудникам;
* изменение личных данных в личном кабинете;
* поск информации по всем заказам и книжным изданиям.

**Пример взаимодействия с приложением**

Пользователь с правами администратора (далее - администратор) оформляет заказ на книжное издание. 
Ему необходимо ввести данные о книге (название, имя автора), выбрать тип и формат издания из соответствующих списков. 
Также необходимо ввести имя и контактную информацию заказчика (номер телефона и email). 
Поля "сроки" и "описание" являются необязательными.
После создания заказа администратор автоматически переходит на страницу этого заказа, 
где может загрузить файлы книжного издания, изменить данные о заказе.
Также администратор может назначить сотрудника на выполнение определенного задания по этому заказу. Для этого необходимо нажать кнопку "Добавить задачу", в открывшемся окне ввести название задания и выбрать сотрудника из списка.
Задача автоматически отобразится в таблице на странице заказа. Помимо указанной администратором информации там будут отображены дополнительные данные о задаче: дата начала выполнения и статус задачи (уставливаются автоматически).
Также для каждой задачи будет доступна функция изменения названия и пользователя (кнопка "Изменить").

Пользователь получивший новое задание, сможет увидеть краткую информацию о заказе в личном кабинете.
Полную информацию пользователь сможет увидеть, щелкнув левой кнопкой по названию книги. 
Пользователю без прав администратора будет доступно ограниченное изменение заказа:
* название книги;
* имя автора;
* описание заказа;
* номер заказа;
* учетно-издательские листы;
* условно-печатные листы;
* ISBN;
* тираж;
* загрузка файлов.

После выволнения поставленной задачи, пользователь кликает по кнопке "Выполнено" напротив соответствующей задачи в личном кабинете.
Статус задачи автоматически обновляется, информация о задаче более не отображается в личном кабинете пользователя.

### Структура базы данных

![image](https://github.com/Fafurin/publ-api/assets/74258308/713f4801-aef4-4b52-93dc-3acf73f47c5e)

### Создание проекта Symfony

Для того чтобы инициализировать новый проект с помощью утилиты symfony cli, выполняем следующую команду:

_symfony new publ-api_

где publ-api - название проекта.

Для дальнейшей работы нам потребуются следующие пакеты:
* **ORM Pack** обеспечит поддержку ORM Doctrine для доступа к инструментам, которые нам нужны для использования баз данных в нашем приложении (composer require symfony/orm-pack);
* **Maker Bundle** упростит нам работу при создании сущностей (composer require --dev symfony/maker-bundle).

Для хранения данных нашего приложения будем использовать бд PostgreSQL.
В файле .env раскомментируем следующую срочку
_DATABASE_URL="postgresql://db_user:db_password@127.0.0.1:5432/db_name?serverVersion=11&charset=utf8"_


где db_user - имя пользователя, db_password - пароль, db_name - название бд.

Теперь, когда наши параметры соединения настроены, Doctrine может создать для нас бд db_name:

_symfony console doctrine:database:create_

Далее необходимо описать вышеупомянутую Doctrine.

### ORM Doctrine

В кратце Doctrine — объектно-реляционное отображение или Object Relational Mapper (ORM) для PHP 7.1+, который базируется на слое абстракции доступа к БД (DBAL). Одной из ключевых возможностей Doctrine является запись запросов к БД на собственном объектно-ориентированном диалекте SQL, называемом DQL (Doctrine Query Language) и базирующемся на идеях HQL (Hibernate Query Language).
Давайте разберемся чего же необходимо это объектно-реляционное отображение.

Классический пример веб-приложения в плане компонентов — это UI, через который пользователь взаимодействует с приложением, backend, содержащий бизнес-логику, и persistence-уровень, в котором хранятся данные и в качестве которого выступает реляционная база данных (БД).

Учитывая, что знакомые нам реляционная БД и классические классы в ООП предполагают разные подходы к хранению данных, а также механизмы управления этими данными, возникает задача синхронизации изменений между этими уровнями.

Задача синхронизации довольно сложна и содержит в себе большой спектр подзадач, среди которых маппинг, вычисление изменений, безопасность, оптимизационные мероприятия и т. д.

Object Relational Mapper (ORM) — это как раз тот инструмент, который берет решение всех этих задач на себя. Помимо этого он предоставляет ряд дополнительных полезных возможностей, таких как Events, QueryBuilder, DQL для быстрого построения запросов и т.д.

ORM Doctrine со 2-й версии реализует паттерн Data mapper (в отличие от Laravel-ского ORM Eloquent, реализующей антипаттерн Active Record).

Data mapper решает задачу обмена данными между объектной и реляционной схемами за счет изоляции объектов и БД относительно друг друга и в качестве основной, концептуальной абстракции использует Entity.

По факту, Entity — это обычный PHP класс, где свойства сопоставлены с полями таблицы из базы данных, для которой и создавалась Entity (далее «сущность»). Всю же работу по маппингу полей, вычислению изменений и т.д. берет на себя mapper.

![1 копия](https://github.com/Fafurin/publ-api/assets/74258308/4730c4f8-978d-4b0f-b672-2a85c36e7685)


### Создание сущностей

С помощью команды make:entity пакета Maker Bundle сгенерируем сущность - вид книжного издания с двумя полями: текстовым title и логическим isDeleted.

_symfony console make:entity BookType_

Полный результат выполнения команды указан ниже:

created: src/Entity/BookType.php

created: src/Repository/BookTypeRepository.php

Entity generated! Now let's add some fields!
You can always add more fields later manually or by re-running this command.

New property name (press <return> to stop adding fields):
> title

Field type (enter ? to see all types) [string]:
>

Field length [255]:
>

Can this field be null in the database (nullable) (yes/no) [no]:
>

updated: src/Entity/BookType.php

Add another property? Enter the property name (or press <return> to stop adding fields):
> isDeleted

Field type (enter ? to see all types) [boolean]:
>

Can this field be null in the database (nullable) (yes/no) [no]:
>

updated: src/Entity/BookType.php

Add another property? Enter the property name (or press <return> to stop adding fields):
>

Success!

Next: When you're ready, create a migration with make:migration

Далее необходимо сгенерировать миграцию:

_symfony console make:migration_

В файле миграции на основе класса BookType создается таблица в нашей базе данных.

Далее необходимо выполнить сгенерированную миграцию:

_symfony console doctrine:migrations:migrate_

Также при создании сущности Maker Bundle автоматически создает репозиторий для этой сущности.
Эти репозитории - классы для работы с таблицей бд. Репозитории нужны, чтобы абстрагироваться от хранилища.
